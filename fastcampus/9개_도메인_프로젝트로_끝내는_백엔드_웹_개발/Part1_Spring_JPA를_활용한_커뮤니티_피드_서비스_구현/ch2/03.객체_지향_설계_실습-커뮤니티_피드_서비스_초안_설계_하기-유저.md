### 유저 생성
1. 유저의 정보를 입력 받습니다. // Controller
2. 유저의 유효성 정보를 확인합니다.(이름 빈 값인지)
3. 유저의 정보를 저장합니다. // Repository


### 팔로우  기능
1. 팔로우 유저, 팔로우 당하는 유저를 입력 받고 불러오기 // Controller, Service
2. 팔로우 저장 여부 확인하기 // Repository
- 팔로우 상태시 에러 반환 // Service
3. 자기 자신인 경우 에러 반환 // Domain
4. 팔로우 유저 카운트 변경하기 // Domain
5. 팔로잉 유저 카운트 변경하기 // Domain
6. 팔로우 여부 저장 및 유저 변경 사항 저장 // Repository


실무에서 문제를 고민할 때, 비즈니스 로직이 어떤 식으로 변경이 될 지 고민해보는 것도 좋다.
"이 책임을 어떤 레이어에서 처리를 하지?", "그 외에 뭔가 비즈니스 로직이 추가 구현되야 하는게 있나?"

객체지향 생활체조에는 디미터의 법칙이 있다. "친구와만 대화하라!"  
자신의 소유 객체랑만 일을 해야지 너무 깊숙히 관여하면 캡슐화가 깨진다!

### 디미터의 법칙을 어겼을 때, 캡슐화가 깨지기 쉬운 이유
내부 구현의 노출
디미터의 법칙을 어기면 다른 객체의 내부 구조나 메서드 호출 체인을 통해 특정 객체의 세부 구현이 노출됩니다.
```java
order.getCustomer().getAddress().getCity();
```
위 코드는 order, customer, address의 내부 구현이 호출 체인으로 노출되었기 때문에, 이 객체들 중 하나라도 변경되면 호출한 코드를 수정해야 합니다. 이는 캡슐화가 깨진 상태입니다.


높은 결합도
객체가 자신과 관련 없는 객체의 세부 구현에 의존하게 되면, 결합도가 높아집니다. 결합도가 높아지면 변경에 취약한 코드가 되고, 유지보수성이 떨어집니다.
예를 들어, 만약 getCustomer(), getAddress() 메서드가 변경되거나 사라지면 이 호출 체인을 사용하는 모든 코드를 수정해야 합니다.


객체 책임의 모호성
디미터의 법칙을 어기면 **한 객체가 너무 많은 다른 객체의 책임을 대신 떠맡게 됩니다.** 이는 객체의 역할을 명확히 정의하지 못하고, 객체 간의 경계를 흐리게 합니다.
예를 들어, order 객체가 customer와 address의 세부 사항을 직접 호출하여 처리한다면, "누가 무엇을 책임져야 하는가?"라는 질문이 모호해집니다.


테스트와 변경의 어려움
내부 구현이 노출되면, 객체 간의 의존성이 깊어지고, 테스트하기 어려워집니다. 또한 객체 내부의 세부 사항이 변경될 경우, 해당 객체와 관련된 다른 모든 코드도 함께 수정해야 합니다.


### 게시글 작성
1. 게시글의 정보를 입력받는다.
2. 유저 유효성 확인 - 존재하는 유저인가?
3. 게시글의 유효성 확인 (5자 이상 500자 이하) // Domain
4. DB 게시글 저장
