게시글에 대한 댓글의 갯수를 저장하고 있지 않다는 문제점  
내가 팔로우한 사람들의 글을 전부 불러온 뒤에 시간 순으로 정리해야 한다는 문제점  

### 댓글의 대한 개수 추가하기

좋아요는 도메인을 업데이트하는 형식으로 했으니, 이번에는 엔티티로만 구현해보자  
```java
package org.sangyunpark99.post.repository.entity.post;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.DynamicUpdate;
import org.sangyunpark99.common.repository.entity.TimeBaseEntity;
import org.sangyunpark99.post.domain.Like;
import org.sangyunpark99.post.domain.Post;
import org.sangyunpark99.post.domain.content.PostContent;
import org.sangyunpark99.post.domain.content.PostState;
import org.sangyunpark99.user.repository.entity.UserEntity;

@Entity
@Table(name = "community_post")
@NoArgsConstructor
@DynamicUpdate
@Getter
public class PostEntity extends TimeBaseEntity {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String content;

    @Convert(converter = PostStateConverter.class)
    private PostState state;

    private Integer likeCount;
    
    @ColumnDefault("0")
    private int commentCount;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "author_id", foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT))
    private UserEntity author;

    public PostEntity(Post post) {
        this.id = post.getId();
        this.content = post.getContentText();
        this.likeCount = post.getLikeCount();
        this.author = new UserEntity(post.getAuthor());
        this.state = post.getState();
    }

    public Post toPost() {
        return Post.builder()
                .id(id)
                .content(new PostContent(content))
                .state(state)
                .author(author.toUser())
                .likeCount(new Like(likeCount))
                .build();
    }
}

```
commentCount는 DB에서 관리되는 값이므로 Wrapper Class가 아닌, Primitive Type으로 구현해줍니다.  
@ColumnDefault("0")을 선언해주는 경우 DB에서 자동으로 0값으로 기본값을 갖도록 합니다.  

테이블 삭제 후, 다시 생성하면 다음과 같이 됩니다. 
```sql
Hibernate: 
    create table community_post (
        id bigint not null auto_increment,
        mod_date datetime(6),
        reg_date datetime(6),
        comment_count integer default 0 not null,
        content varchar(255),
        like_count integer,
        state varchar(255),
        author_id bigint,
        primary key (id)
    ) engine=InnoDB
```
comment_count integer default 0 not null 이라는 쿼리문이 실행됩니다.  

![img_26.png](img_26.png)  

기존처럼 likeCount를 증가하는 방식은 역할을 객체에 위임하고 유연하게 사용할 수 있다는 장점이 있지만, repository의 기능 만으로도 따로 만들어 주지 않아도 기능 구현이 가능했다.  

### 피드 조회 기능 구현하기

내가 팔로잉하고 있는 유저의 게시물을 갖고 오기 위해선 다음과 같은 플로우를 거치게 됩니다.  
(1) 팔로잉 유저 목록 조회
(2) 각 유저가 작성한 게시물 목록 조회
(3) 조회한 게시물을 시간순으로 정렬

이러한 플로우를 단축하는 것은 어떨까요?  
내가 팔로잉하고 있는 유저의 게시물 Id 목록을 갖고 있는 하나의 테이블을 만들어주는 것입니다.  

1번 유저가 2번 유저 팔로우
1번 유저가 3번 유저 팔로우

2번 유저의 글쓰기, 3번 유저의 글쓰기는 아래와 같습니다.

1번 유저의 글쓰기 -> 아무도 1번을 팔로우하지 않으므로 UserPostQueue에 쌓이지 않게 됩니다.  
조회할때는 User ID를 사용해서 조회를 하고, 순서대로 피드를 정렬할때는 Post ID를 기준으로 정렬하면 됩니다.  
UserPostQueue  
USER ID / POST ID / AUTHOR ID  
1 / 1 / 2  
1 / 2 / 3  

```java
package org.sangyunpark99.post.repository.post_queue;

import org.sangyunpark99.post.repository.entity.post.PostEntity;

public interface UserPostQueueCommentRepository {
    
    void publishPost(PostEntity postEntity);
    
    void saveFollowPost(Long userId, Long targetId);
    
    void deleteUnfollowPost(Long userid, Long targetId);
}
```
이 인터페이스를 레파지토리 하위에 넣은 이유는 이 인터페이스는 서비스 레이어에 노출이 되어서는 안되는 레파지토리이기 때문이다.  
서비스 레이어의 특징으로는 repo, domin, controller에서 오는 데이터를 전달하고, 가공하는 중간단의 역할로 생각을 했다.  

Command Repositroy와 Read Repository를 분리해서 구현해줍니다.  

팔로워를 찾는 로직은 아래와 같습니다.  
```java
package org.sangyunpark99.user.repository.jpa;

import org.sangyunpark99.user.repository.entity.UserRelationIdEntity;
import org.sangyunpark99.user.repository.entity.UserRelationshipEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import java.util.List;

public interface JpaUserRelationRepository extends JpaRepository<UserRelationshipEntity, UserRelationIdEntity> {
    
    @Query("SELECT u.followingUserId FROM UserRelationshipEntity u WHERE u.followerUserId = :userId")
    List<Long> findFollowers(Long userId);
}
```

삭제 로직은 기존 방식처럼 엔티티에 들어갈 값들을 기준으로 하는 것이 아닌, 

```java
public interface JpaUserPostQueueRepository extends JpaRepository<UserPostQueueEntity, Long> {
    
    void deleteAllByUserIdAndAuthorId(Long userId, Long targetId);
}
```
이런방식으로 jpa의 장점을 활용해 userId와 targetId만으로 deleteAll 쿼리를 작성할 수 있습니다.  