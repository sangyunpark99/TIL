### 피드 서비스

Q. 정적 메서드를 사용하면 어떤 장점이 존재할까?  
메서드 명으로 어떤 생성자인지 알려주므로, 유지 보수가 쉽다. (명확하게 이름을 나타낼 수 있습니다.)
ex) createPost, createDefaultPost  

정적 생성자 메서드를 사용해서 객체를 반환해주는 방법  
```java
public static Comment createComment(Post post, User user, String content) {
        return new Comment(null, new CommentContent(content), post, user);
    }

    public Comment(Long id, CommentContent content, Post post, User author) {

        if(author == null) {
            throw new IllegalArgumentException();
        }

        if(post == null) {
            throw new IllegalArgumentException();
        }

        if(content == null) {
            throw new IllegalArgumentException();
        }

        this.id = id;
        this.post = post;
        this.author = author;
        this.content = content;
        this.likeManager = new Like();
    }
```

Q. 생성자에 매개변수가 많은 경우는 유지 보수 하기 힘들지 않은가?
(1) Builder 패턴을 사용하라! (@Builder)
(2) 객체를 좀 더 작은 객체로 나눕니다.(한개 혹은 두개의 상태값 이상을 갖지 못하게 나누는 것입니다.)


Q. 매번 테스트를 만들때마다 값들을 주입받고, 생성하고 만드는 것은 테스트가 복잡해지고, 서비스에서 들어가는 인자기 바뀌는 경우 모든 테스트 코드를 변경해야 하지 않나요? 
FakeObjectFactory를 싱글톤 패턴으로 만들어서 해결하면 됩니다.  

```java
package org.sangyunpark99.fake;

import org.sangyunpark99.post.application.CommentService;
import org.sangyunpark99.post.application.PostService;
import org.sangyunpark99.post.application.interfaces.CommentRepository;
import org.sangyunpark99.post.application.interfaces.LikeRepository;
import org.sangyunpark99.post.application.interfaces.PostRepository;
import org.sangyunpark99.post.domain.repository.FakeCommentRepository;
import org.sangyunpark99.post.domain.repository.FakeLikeRepository;
import org.sangyunpark99.post.domain.repository.FakePostRepository;
import org.sangyunpark99.user.application.UserRelationService;
import org.sangyunpark99.user.application.UserService;
import org.sangyunpark99.user.application.interfaces.UserRelationRepository;
import org.sangyunpark99.user.application.interfaces.UserRepository;
import org.sangyunpark99.user.repository.FakeUserRelationRepository;
import org.sangyunpark99.user.repository.FakeUserRepository;

public class FakeObjectFactory {

    private static final UserRepository userRepository = new FakeUserRepository();
    private static final UserRelationRepository userRelationRepository = new FakeUserRelationRepository();
    private static final PostRepository postRepository = new FakePostRepository();
    private static final CommentRepository commentRepository = new FakeCommentRepository();
    private static final LikeRepository likeRepository = new FakeLikeRepository();

    private static final UserService userService = new UserService(userRepository);
    private static final UserRelationService userRelationService = new UserRelationService(userService,
            userRelationRepository);
    private static final PostService postService = new PostService(postRepository,likeRepository,userService);
    private static final CommentService commentService = new CommentService(commentRepository,userService,postService
            ,likeRepository);


    private FakeObjectFactory() {

    }

    public static PostService getPostService() {
        return postService;
    }

    public static UserService getUserService() {
        return userService;
    }

    public static CommentService getCommentService() {
        return commentService;
    }

    public static UserRelationService userRelationService() {
        return userRelationService;
    }
}
```

### Fake 객체 만들기 

Post
```java
package org.sangyunpark99.post.domain.repository;

import org.sangyunpark99.post.application.interfaces.PostRepository;
import org.sangyunpark99.post.domain.Post;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

public class FakePostRepository implements PostRepository {

    private final Map<Long,Post> store = new HashMap<>();

    @Override
    public Post save(Post post) {

        if(post.getId() != null) {
            store.put(post.getId(), post);
            return post;
        }

        long id = store.size() + 1;
        Post newPost = new Post(id, post.getAuthor(), post.getContent());
        store.put(id, newPost);

        return newPost;
    }

    @Override
    public Optional<Post> findById(Long id) {
        return Optional.ofNullable(store.get(id));
    }
}
```

Comment
```java
package org.sangyunpark99.post.domain.repository;

import org.sangyunpark99.post.application.interfaces.CommentRepository;
import org.sangyunpark99.post.domain.comment.Comment;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

public class FakeCommentRepository implements CommentRepository {

    private final Map<Long, Comment> store = new HashMap<>();

    @Override
    public Comment save(Comment comment) {
        if(comment.getId() != null) {
            store.put(comment.getId(), comment);
            return comment;
        }

        long id = store.size() + 1;
        Comment newComment = new Comment(id, comment.getCommentContent(), comment.getPost(), comment.getAuthor());
        store.put(id, newComment);
        return newComment;
    }

    @Override
    public Optional<Comment> findById(Long id) {
        return Optional.ofNullable(store.get(id));
    }
}
```